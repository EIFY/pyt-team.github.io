
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>toponetx.classes.cell &#8212; TopoNetX latest documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/alabaster.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery.css" />
    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/sphinx_highlight.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <link rel="canonical" href="pyt-team.github.io/_modules/toponetx/classes/cell.html" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for toponetx.classes.cell</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Cell and CellView classes.&quot;&quot;&quot;</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Iterable</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Iterable</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Counter</span><span class="p">,</span> <span class="n">deque</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">zip_longest</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Cell&quot;</span><span class="p">]</span>


<div class="viewcode-block" id="Cell"><a class="viewcode-back" href="../../../api/classes.html#toponetx.classes.cell.Cell">[docs]</a><span class="k">class</span> <span class="nc">Cell</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Class representing a 2D cell.</span>

<span class="sd">     A 2D cell is an elementary building block used to build a 2D cell complex, whether regular or non-regular.</span>

<span class="sd">     Parameters</span>
<span class="sd">     ----------</span>
<span class="sd">     elements : iterable of hashable objects</span>
<span class="sd">         An iterable that contains hashable objects representing the nodes of the cell. The order of the elements is important</span>
<span class="sd">         and defines the cell up to cyclic permutation.</span>
<span class="sd">     name : str, optional</span>
<span class="sd">         A string representing the name of the cell. The default value is None.</span>
<span class="sd">     regular : bool, optional</span>
<span class="sd">         A boolean indicating whether the cell satisfies the regularity condition. The default value is True.</span>
<span class="sd">         A 2D cell is regular if and only if there is no repetition in the boundary edges that define the cell.</span>
<span class="sd">         By default, the cell is assumed to be regular unless otherwise specified. Self-loops are not allowed in the boundary</span>
<span class="sd">         of the cell. If a cell violates the cell complex regularity condition, a ValueError is raised.</span>
<span class="sd">     **attr : keyword arguments, optional</span>
<span class="sd">         Properties belonging to the cell can be added as key-value pairs. Both the key and value must be hashable.</span>

<span class="sd">     Notes</span>
<span class="sd">     -----</span>
<span class="sd">     - A cell is defined as an ordered sequence of nodes (n1, ..., nk), where each two consecutive nodes (ni, ni+1)</span>
<span class="sd">       define an edge in the boundary of the cell. Note that the last edge (nk, n1) is also included in the boundary</span>
<span class="sd">       of the cell and is used to close the cell. For instance, if a Cell is defined as `c = Cell((1, 2, 3))`,</span>
<span class="sd">       then `c.boundary` will return `[(1, 2), (2, 3), (3, 1)]`, which consists of three edges.</span>
<span class="sd">    - When cell is created, its boundary is automatically created as a</span>
<span class="sd">       set of edges that encircle the cell.</span>
<span class="sd">     Examples</span>
<span class="sd">     --------</span>
<span class="sd">     &gt;&gt;&gt; cell1 = Cell((1, 2, 3))</span>
<span class="sd">     &gt;&gt;&gt; cell2 = Cell((1, 2, 4, 5), weight=1)</span>
<span class="sd">     &gt;&gt;&gt; cell3 = Cell((&quot;a&quot;, &quot;b&quot;, &quot;c&quot;))</span>
<span class="sd">     &gt;&gt;&gt; # create geometric cell:</span>
<span class="sd">     &gt;&gt;&gt; v0 = (0, 0)</span>
<span class="sd">     &gt;&gt;&gt; v1 = (1, 0)</span>
<span class="sd">     &gt;&gt;&gt; v2 = (1, 1)</span>
<span class="sd">     &gt;&gt;&gt; v3 = (0, 1)</span>
<span class="sd">     # create the cell with the vertices and edges</span>
<span class="sd">     &gt;&gt;&gt; cell = Cell([v0, v1, v2, v3],type=&quot;square&quot;)</span>
<span class="sd">     &gt;&gt;&gt; cell[&quot;type&quot;]</span>
<span class="sd">     &gt;&gt;&gt; print(list(cell.boundary))</span>
<span class="sd">     [((0, 0), (1, 0)), ((1, 0), (1, 1)), ((1, 1), (0, 1)),</span>
<span class="sd">      ((0, 1), (0, 0))]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elements</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">regular</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">attr</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;_&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_regular</span> <span class="o">=</span> <span class="n">regular</span>
        <span class="n">elements</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">elements</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_boundary</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
            <span class="n">zip_longest</span><span class="p">(</span><span class="n">elements</span><span class="p">,</span> <span class="n">elements</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="p">[</span><span class="n">elements</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
        <span class="p">)</span>  <span class="c1"># list of edges define the boundary of the 2d cell</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">elements</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;cell must contain at least 2 edges, got </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">elements</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">regular</span><span class="p">:</span>
            <span class="n">_adjdict</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boundary</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">_adjdict</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot; Node </span><span class="si">{</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> is repeated multiple times in the input cell.&quot;</span>
                        <span class="o">+</span> <span class="s2">&quot; Input cell violates the cell complex regularity condition.&quot;</span>
                    <span class="p">)</span>
                <span class="n">_adjdict</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>

            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boundary</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;self loops are not permitted, got </span><span class="si">{</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="si">}</span><span class="s2"> as an edge in the cell&#39;s boundary&quot;</span>
                    <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_elements</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">elements</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">properties</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Retrieve the value associated with the given key in the properties dictionary.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        item : hashable</span>
<span class="sd">            The key to retrieve from the properties dictionary.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        The value associated with the given key in the properties dictionary.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        KeyError:</span>
<span class="sd">            If the given key is not in the properties dictionary.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">item</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;attr </span><span class="si">{</span><span class="n">item</span><span class="si">}</span><span class="s2"> is not an attr in the cell </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="p">[</span><span class="n">item</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Set the value associated with the given key in the properties dictionary.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        key : hashable</span>
<span class="sd">            The key to set in the properties dictionary.</span>
<span class="sd">        item : hashable</span>
<span class="sd">            The value to associate with the given key in the properties dictionary.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">item</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_regular</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns true is the Cell is a regular cell, and False otherwise</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_regular</span><span class="p">:</span>  <span class="c1"># condition enforced</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_adjdict</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boundary</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">_adjdict</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
                <span class="n">_adjdict</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Get the number of elements in the cell.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">            The number of elements in the cell.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_elements</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Iterate over the elements in the cell.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        iterator</span>
<span class="sd">            An iterator over the elements in the cell.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_elements</span><span class="p">)</span>

<div class="viewcode-block" id="Cell.sign"><a class="viewcode-back" href="../../../api/classes.html#toponetx.classes.cell.Cell.sign">[docs]</a>    <span class="k">def</span> <span class="nf">sign</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;The sign method of the Cell class takes an edge as input and returns the sign of the edge with respect to the cell. If the edge is in the boundary of the cell, then the sign is 1 if the edge is in the counterclockwise direction around the cell and -1 if it is in the clockwise direction. If the edge is not in the boundary of the cell, a KeyError is raised.</span>

<span class="sd">        Args:</span>

<span class="sd">        edge: an iterable representing the edge whose sign with respect to the cell is to be computed.</span>
<span class="sd">        Returns:</span>

<span class="sd">        1: if the edge is in the boundary of the cell and is in the counterclockwise direction around the cell.</span>
<span class="sd">        -1: if the edge is in the boundary of the cell and is in the clockwise direction around the cell.</span>
<span class="sd">        Raises:</span>

<span class="sd">        KeyError: if the input edge is not in the boundary of the cell.</span>
<span class="sd">        ValueError: if the input edge is not iterable or if its length is not 2.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">edge</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary</span><span class="p">:</span>
                    <span class="k">return</span> <span class="mi">1</span>
                <span class="k">elif</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">edge</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary</span><span class="p">:</span>
                    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;the input </span><span class="si">{</span><span class="n">edge</span><span class="si">}</span><span class="s2"> is not in the boundary of the cell&quot;</span>
                    <span class="p">)</span>

            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;the input </span><span class="si">{</span><span class="n">edge</span><span class="si">}</span><span class="s2"> is not a valud edge&quot;</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;the input </span><span class="si">{</span><span class="n">edge</span><span class="si">}</span><span class="s2"> must be iterable&quot;</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">e</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elements</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        String representation of regular cell</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;Cell</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">elements</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">boundary</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        a 2d cell is characterized by its boundary edges</span>
<span class="sd">        Return</span>
<span class="sd">        ------</span>
<span class="sd">        iterator of tuple representing boundary edges given in cyclic order</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_boundary</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">elements</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Elements of the cell.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elements</span>

<div class="viewcode-block" id="Cell.reverse"><a class="viewcode-back" href="../../../api/classes.html#toponetx.classes.cell.Cell.reverse">[docs]</a>    <span class="k">def</span> <span class="nf">reverse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Reverse the sequence of nodes that defines the cell.</span>

<span class="sd">        This returns a new cell with the new reversed elements.</span>

<span class="sd">        Return : Cell</span>
<span class="sd">        ------</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">Cell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_elements</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">regular</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_regular</span><span class="p">)</span>
        <span class="n">c</span><span class="o">.</span><span class="n">properties</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">properties</span>
        <span class="k">return</span> <span class="n">c</span></div>

<div class="viewcode-block" id="Cell.is_homotopic_to"><a class="viewcode-back" href="../../../api/classes.html#toponetx.classes.cell.Cell.is_homotopic_to">[docs]</a>    <span class="k">def</span> <span class="nf">is_homotopic_to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cell</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cell : tuple, list or Cell</span>

<span class="sd">        Return</span>
<span class="sd">        ------</span>
<span class="sd">        _ : bool</span>
<span class="sd">            Return True is self is homotopic to input cell and False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">Cell</span><span class="o">.</span><span class="n">_are_homotopic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cell</span><span class="p">)</span> <span class="ow">or</span> <span class="n">Cell</span><span class="o">.</span><span class="n">_are_homotopic</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reverse</span><span class="p">(),</span> <span class="n">cell</span>
        <span class="p">)</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_are_homotopic</span><span class="p">(</span><span class="n">cell1</span><span class="p">,</span> <span class="n">cell</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters:</span>
<span class="sd">        ---------</span>
<span class="sd">        cell1 : Cell</span>
<span class="sd">        cell : tuple, list or Cell</span>

<span class="sd">        Return : bool</span>
<span class="sd">        ------</span>
<span class="sd">            return True is self is homotopic to input cell and False otherwise.</span>

<span class="sd">        Note :</span>
<span class="sd">        -------</span>
<span class="sd">            in a 2d-cell complex, two 2d-cells are homotopic iff one</span>
<span class="sd">                of them can be obtaine from the other by a cylic rotation</span>
<span class="sd">                of the boundary verties defining the 2d cells.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">seq</span> <span class="o">=</span> <span class="n">cell</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">Cell</span><span class="p">):</span>
            <span class="n">seq</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">elements</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;input type must be a tuple/list of nodes defining a cell or Cell&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cell1</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cell</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="n">mset1</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
        <span class="n">mset2</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">cell1</span><span class="o">.</span><span class="n">elements</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mset1</span> <span class="o">!=</span> <span class="n">mset2</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="n">size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
        <span class="n">deq1</span> <span class="o">=</span> <span class="n">deque</span><span class="p">(</span><span class="n">cell1</span><span class="o">.</span><span class="n">elements</span><span class="p">)</span>
        <span class="n">deq2</span> <span class="o">=</span> <span class="n">deque</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">):</span>
            <span class="n">deq2</span><span class="o">.</span><span class="n">rotate</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">deq1</span> <span class="o">==</span> <span class="n">deq2</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        String representation of regular cell</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;Nodes set:</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_elements</span><span class="si">}</span><span class="s2">, boundary edges:</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">boundary</span><span class="si">}</span><span class="s2">, attrs:</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="si">}</span><span class="s2">&quot;</span></div>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../index.html">TopoNetX</a></h1>








<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../api/index.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/index.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contributing/index.html">Contributing Guide</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2022-2023, PyT-Team, Inc..
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 5.3.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
    </div>

    

    
  </body>
</html>